<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="stylesheet" href="styles/main.css" />
		<title>A4D Level Editor</title>
		<script
			src="https://twemoji.maxcdn.com/v/latest/twemoji.min.js"
			crossorigin="anonymous"
		></script>
		<script>
			window.onload = function () {
				twemoji.parse(document.body, {
					folder: "svg",
					ext: ".svg",
				});
			};
		</script>
		<style>
			img.emoji {
				width: 3em;
				pointer-events: none;
				-webkit-user-select: none;		
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
		</style>
		<link
			rel="apple-touch-icon"
			sizes="120x120"
			href="favicons/apple-touch-icon.png"
		/>
		<link
			rel="icon"
			type="image/png"
			sizes="32x32"
			href="favicons/favicon-32x32.png"
		/>
		<link
			rel="icon"
			type="image/png"
			sizes="16x16"
			href="favicons/favicon-16x16.png"
		/>
		<link rel="manifest" href="favicons/site.webmanifest" />
		<link
			rel="mask-icon"
			href="favicons/safari-pinned-tab.svg"
			color="#5bbad5"
		/>
		<link rel="shortcut icon" href="favicons/favicon.ico" />
		<meta name="msapplication-TileColor" content="#da532c" />
		<meta
			name="msapplication-config"
			content="favicons/browserconfig.xml"
		/>
	</head>
	<body>
		<div id="Top">
			<h1>Appel for DISCORD Level Editor</h1>
			<nav>
				<ul>
					<li>
						<a href="https://discord.gg/aR8pBRXYd3">Discord</a>
					</li>
					<li>
						<a href="https://wasteof.money/posts/62d300eb67a84704d267027b">Help</a>
					</li>
					<li>
						<a href="https://late-is-cool.github.io/a4d-editor">Credit to late</a>
					</li>
				</ul>
			</nav>
		</div>
		<br />
		<section id="Level">
			<button draggable="true" id="Resize-Handle"></button>
		</section>
		<div id="Warning-Container">
			<div id="Warning">
				<span id="Warning-Text"></span>
				<button class="tool-button" id="Warning-Close">
					&Cross;
				</button>
			</div>
		</div>
		<section id="Toolbar">
			<div id="Toolbar-Left">
				<button title="Erase" data-tool="erase" class="tool tool-button">
					🟦
				</button>
				<button title="Ground" data-tool="obstacle" class="tool tool-button selected">
					🟩
				</button>
				<button title="Apple" data-tool="apple" class="tool tool-button">
					🍏
				</button>
				<button title="Mob" data-tool="enemy" class="tool tool-button">
					🟥
				</button>
				<button title="Checkpoint" data-tool="checkpoint" class="tool tool-button">
					🏁
				</button>
				<button title="Spike" data-tool="spike" class="tool tool-button">
					🔼
				</button>
				<!--
				"you can ignore the moving platforms"
				<button title="Moving Platform" data-tool="moving" class="tool tool-button">
					🇲
				</button>
				-->
			</div>
			<div id="Toolbar-Right">
				<span id="Size"></span>
				<button title="Pick" data-tool="pick" class="tool tool-button">
					📋
				</button>
				<button title="Clear Level" data-tool="_clear" class="tool tool-button">
					📄
				</button>
				<button title="Export Level" data-tool="_export" class="tool tool-button">
					💾
				</button>
				<button title="Import Level" data-tool="_import" class="tool tool-button">
					📂
				</button>
			</div>
		</section>
		<script>
			let levelSection = document.getElementById("Level");
			let resizeHandle = document.getElementById("Resize-Handle");
			let size = document.getElementById("Size");
			let toolbar = document.getElementById("Toolbar");
			let warningText = document.getElementById("Warning-Text");
			let warning = document.getElementById("Warning");
			
			const TILES = {
				SKY: "🟦",
				OBSTACLE: "🟩",
				APPLE: "🍏",
				ENEMY: "🟥",
				CHECKPOINT: "🏁",
				SPIKE: "🔼",
				MOVING: "🇲",
			}
			
			let levelObject = {
				width: 0,
				height: 0,
				obstacles: [],
				apples: [],
                bigApple: {},
				enemies: [],
				checkpoints: [],
                spikes: [],
                moving: [],
			}
			let realWidth, realHeight;
			let selectedTool = "obstacle";
			
			levelSection.addEventListener("mousedown", doClick);
			levelSection.addEventListener("mousemove", doClick);
			levelSection.addEventListener("contextmenu", (ev) => {
				const tile = ev.target;
				if (!tile || !tile.classList.contains("tile")) return;
				
				ev.preventDefault();
			});
			
			function doClick(ev) {
				if (!ev.buttons) return;
				if (resizing) return;
				
				const tile = ev.target;
				if (!tile || !tile.classList.contains("tile")) return;
				
				if (tile.classList.contains("locked")) return;
				
				const posFunc = (element) =>
					element.x === Number(tile.dataset.x) &&
					element.y === Number(tile.dataset.y);
				const eraseFunc = (element) =>
					element.x !== Number(tile.dataset.x) ||
					element.y !== Number(tile.dataset.y);
				const erase = () => {
					levelObject.obstacles = levelObject.obstacles.filter(eraseFunc);
					levelObject.apples = levelObject.apples.filter(eraseFunc);
					levelObject.enemies = levelObject.enemies.filter(eraseFunc);
					levelObject.checkpoints = levelObject.checkpoints.filter(eraseFunc);
					levelObject.spikes = levelObject.spikes.filter(eraseFunc);
					levelObject.moving = levelObject.moving.filter(eraseFunc);
				}
				
				if (selectedTool === "pick" || ev.buttons & 4) {
					if (levelObject.obstacles.some(posFunc)) {
						selectedTool = "obstacle";
					} else if (levelObject.enemies.some(posFunc)) {
						selectedTool = "enemy";
					} else if (levelObject.apples.some(posFunc)) {
						selectedTool = "apple";
					} else if (levelObject.checkpoints.some(posFunc)) {
						selectedTool = "checkpoint";
					} else if (levelObject.moving.some(posFunc)) {
						selectedTool = "moving";
					} else if (levelObject.spikes.some(posFunc)) {
						selectedTool = "spike";
					} else {
						selectedTool = "erase";
					}
					updateTool();
					
					ev.preventDefault();
				} else if (ev.buttons & 2 || selectedTool === "erase") {
					tile.dataset.tile = TILES.SKY;
					erase();
				} else if (ev.buttons & 1) {
					const xy = {
						x: Number(tile.dataset.x),
						y: Number(tile.dataset.y),
					};
					erase();
					if (selectedTool === "enemy") {
						tile.dataset.tile = TILES.ENEMY;
						levelObject.enemies.push(xy);
					} else if (selectedTool === "apple") {
						tile.dataset.tile = TILES.APPLE;
						levelObject.apples.push(xy);
					} else if (selectedTool === "checkpoint") {
						tile.dataset.tile = TILES.CHECKPOINT;
						levelObject.checkpoints.push(xy);
					} else if (selectedTool === "spike") {
						tile.dataset.tile = TILES.SPIKE;
						levelObject.spikes.push(xy);
					} else if (selectedTool === "moving") {
						tile.dataset.tile = TILES.MOVING;
						levelObject.moving.push(xy);
					} else {
						tile.dataset.tile = TILES.OBSTACLE;
						levelObject.obstacles.push(xy);
					}
				}
								
				tile.innerText = tile.dataset.tile;
				twemoji.parse(document.body, {
					folder: "svg",
					ext: ".svg",
				});
			}
			
			const download = (text) => {
				let element = document.createElement("a");
				element.setAttribute(
					"href",
					"data:text/plain;charset=utf-8," + encodeURIComponent(text)
				);
				element.setAttribute("download", "level.a4d");
				element.style.display = "none";
				document.body.appendChild(element);
				element.click();
				document.body.removeChild(element);
			}
			const importFile = async () => {
				let input = document.createElement("input");
				input.type = "file";
				input.accept = ".a4d";
				input.click();
				input.onchange = async () => {
					warning.style.display = "";
					let file;
					try {
						file = JSON.parse(await input.files[0].text())
					} catch(e) {
						console.error("error loading level:", e);
						warning.style.display = "inline-block";
						warningText.innerText = "The file you imported is not a valid .a4d file.";
						return;
					}
					/*
						why should we intentionally limit backwards compatibility
						for (let key in levelObject) {
							if (file[key] == undefined) {
								warning.style.display = "inline-block";
								warningText.innerText = "The file you imported is either different or came from an old version of the editor.";
							}
						}
					*/
					const ch = o => isNaN(o) ? null : o;
					const t = e => {
						throw e;
					};
					try {
						levelObject = {
							width: ch(file.width)
								|| t(new Error("width must be a number!")),
							height: ch(file.height)
								|| t(new Error("height must be a number!")),
							obstacles: file.obstacles || [],
							apples: file.apples || [],
							bigApple: file.bigApple || {},
							enemies: file.enemies || [],
							checkpoints: file.checkpoints || [],
							spikes: file.spikes || [],
							moving: file.moving || [],
						}
						// Fix old levels that had X and Y object positions stored as strings
						for (const key of ["obstacles", "apples", "enemies", "checkpoints", "spikes"]) {
							levelObject[key] = levelObject[key].map(v => ({
								...v,
								x: Number(v.x),
								y: Number(v.y),
							}));
						}
						realWidth = levelObject.width * 48;
						realHeight = levelObject.height * 48;
						cleanup();
						createLevel();
					} catch (e) {
						console.error("error loading level:", e);
						warning.style.display = "inline-block";
						warningText.innerText = "Error loading the level. See the browser console for more info.";
						return;
					}
				}
			}
			
			levelObject.width = 21;
			levelObject.height = 15;
			realWidth = levelObject.width * 48;
			realHeight = levelObject.height * 48;
			createLevel();
			
			function cleanup() {
				const filter = el => !isNaN(el.x) && !isNaN(el.y) &&
					el.x >= 0 &&
					el.y >= 0 &&
					el.x < levelObject.width &&
					el.y < levelObject.height - 2;
				levelObject.obstacles = levelObject.obstacles.filter(filter);
				levelObject.apples = levelObject.apples.filter(filter);
				levelObject.checkpoints = levelObject.checkpoints.filter(filter);
				levelObject.enemies = levelObject.enemies.filter(filter);
				levelObject.spikes = levelObject.spikes.filter(filter);
				levelObject.moving = levelObject.moving.filter(filter);
			}
			function createLevel() {
				document.querySelectorAll(".row, .tile").forEach(e => e.remove());
				for (let y = 0; y < levelObject.height; y++) {
					let div = document.createElement("div");
					div.classList.add("row");
					for (let x = 0; x < levelObject.width; x++) {
						let tile = document.createElement("div");
						tile.classList.add("tile");
						
						if (y < levelObject.height - 2) {
							const posMatch = obj => obj.x === x && obj.y === y;
							if (levelObject.obstacles?.some(posMatch)) {
								tile.dataset.tile = TILES.OBSTACLE;
							} else if (levelObject.apples?.some(posMatch)) {
								tile.dataset.tile = TILES.APPLE;
							} else if (levelObject.enemies?.some(posMatch)) {
								tile.dataset.tile = TILES.ENEMY;
							} else if (levelObject.checkpoints?.some(posMatch)) {
								tile.dataset.tile = TILES.CHECKPOINT;
							} else if (levelObject.spikes?.some(posMatch)) {
								tile.dataset.tile = TILES.SPIKE;
							} else if (levelObject.moving?.some(posMatch)) {
								tile.dataset.tile = TILES.MOVING;
							} else {
								tile.dataset.tile = TILES.SKY;
							}
						} else {
							tile.dataset.tile = TILES.OBSTACLE;
							tile.classList.add("locked");
						}
						tile.innerText = tile.dataset.tile;
						tile.dataset.x = x;
						tile.dataset.y = y;
						div.appendChild(tile);
					}
					levelSection.appendChild(div);
					twemoji.parse(document.body, {
						folder: "svg",
						ext: ".svg",
					});
					updateHandle();
				}
			}
			
			let resizing = false;
			resizeHandle.addEventListener("mousedown", () => {
				resizing = true;
				document.body.classList.add("resizing");
			});
			window.addEventListener("mousemove", (ev) => {
				if (!resizing) return;
				const levelRect = levelSection.getBoundingClientRect();
				
				realWidth = ev.clientX - levelRect.left;
				realHeight = ev.clientY - levelRect.top;
				
				updateHandle();
			});
			window.addEventListener("mouseup", () => {
				document.body.classList.remove("resizing");
				if (!resizing) return;
				resizing = false;
				
				const ceilW = Math.max(1,
					Math.round(realWidth / 48)
				);
				const ceilH = Math.max(1,
					Math.round(realHeight / 48)
				);
				if (
					ceilW !== levelObject.width ||
					ceilH !== levelObject.height
				) {
					levelObject.width = ceilW;
					levelObject.height = ceilH;
					cleanup();
					createLevel();
				}
				realWidth = ceilW * 48;
				realHeight = ceilH * 48;
				updateHandle();
			});
			function updateHandle() {
				const ceilW = Math.max(1,
					Math.round(realWidth / 48)
				);
				const ceilH = Math.max(1,
					Math.round(realHeight / 48)
				);
				resizeHandle.style.transform =
					`translate(${ceilW*48}px, ${ceilH*48}px)`;
				size.textContent = `Size: ${ceilW}x${ceilH}`;
			}
			
			twemoji.parse(document.body, {
				folder: "svg",
				ext: ".svg",
			});
			
			document.getElementById("Warning-Close").addEventListener("click", () => {
				warning.style.display = "";
			})
			
			toolbar.addEventListener("click", (ev) => {
				if (!ev.target || !ev.target.classList.contains("tool")) return;
				const tool = ev.target.dataset.tool;
				
				switch (tool) {
					case "_clear":
						if (!confirm("Are you sure you want to clear the level?")) return;
						levelObject.obstacles = [];
						levelObject.enemies = [];
						levelObject.checkpoints = [];
						levelObject.apples = [];
						levelObject.spikes = [];
						levelObject.moving = [];
						levelObject.bigApple = {};
						createLevel();
					break;
					case "_export":
						download(JSON.stringify(levelObject));
					break;
					case "_import":
						importFile();
					break;
				}
				if (tool.startsWith("_")) return;
				
				selectedTool = tool;
				updateTool();
			});
			function updateTool() {
				document.querySelectorAll(".tool").forEach(
					el => el.classList.remove("selected")
				);
				document.querySelector(
					`button.tool[data-tool="${selectedTool}"]`
				)?.classList.add("selected");
			}
		</script>
	</body>
</html>
